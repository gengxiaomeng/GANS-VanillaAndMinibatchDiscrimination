from __future__ import print_function
import torch 
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import numpy as np
import matplotlib.pyplot as plt

# Input dimensions for an MNIST image
MNIST_W = 28
MNIST_H = 28

MNIST_DIM = MNIST_H*MNIST_W
NOISE_DIM = 20
BATCH_SIZE = 10
LEARN_RATE = 1e-4
MAX_EPOCH = 1
# Defining a Generator and Discriminator network
class Generator(nn.Module):

	def __init__(self):
		super(Generator,self).__init__()
		self.lin1 = nn.Linear(NOISE_DIM, 100)
		self.lin2 = nn.Linear(100, 400)
		self.lin3 = nn.Linear(400, MNIST_DIM)

	def forward(self, x):
		x = F.relu(self.lin1(x))
		x = F.relu(self.lin2(x))
		x = self.lin3(x)

		return x

class Discriminator(nn.Module):

	def __init__(self):
		super(Discriminator,self).__init__()
		self.lin1 = nn.Linear(MNIST_DIM, 100)
		self.lin2 = nn.Linear(100, 20)
		self.lin3 = nn.Linear(20, 1)

	def forward(self, x):
		x = F.relu(self.lin1(x))
		x = F.relu(self.lin2(x))
		x = F.sigmoid(self.lin3(x)) # Sigmoid at the last layer because we want to output a probability

		return x

# Download MNIST data and set up DataLoader
transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5, 0.5),(0.5, 0.5))])
trainset = torchvision.datasets.MNIST(root = './data_MNIST',train = True, download = True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size = BATCH_SIZE, shuffle = True, num_workers = 0)
dataiter = iter(trainloader)
	
# Instantiate the generator and discriminator nets
gen1 = Generator()
dis1 = Discriminator()

gen_optimizer = optim.SGD(gen1.parameters(), lr = LEARN_RATE, momentum = 0.9)
dis_optimizer = optim.SGD(dis1.parameters(), lr = LEARN_RATE, momentum = 0.9)
criterion_dis = nn.BCELoss()
criterion_gen = nn.BCELoss()


# Start the training procedure
for epoch in range(MAX_EPOCH):
    for i, data in enumerate(trainloader,0):
        ## Discriminator update step
        true_examples, _ =  data
        
        dis_optimizer.zero_grad()
        # Forward pass 'BATCH_SIZE' number of noise vectors through Generator
        noise_outputs = gen1.forward(torch.randn(BATCH_SIZE,NOISE_DIM))
        # Obtain 'BATCH_SIZE' number of true samples
        true_examples = true_examples.view(-1,MNIST_DIM)
        
        
        # Forward pass "false" and true samples through the discriminator
        # and calculate the respective terms of discriminator loss
        dis_true_loss = criterion_dis(dis1.forward(true_examples),torch.ones([BATCH_SIZE,1],dtype = torch.float32))
        dis_false_loss = criterion_dis(dis1.forward(noise_outputs),torch.zeros([BATCH_SIZE,1],dtype = torch.float32))

        # Calculate discriminator loss and backprop on discriminator params
        dis_loss = dis_true_loss + dis_false_loss
        dis_loss.backward()
        dis_optimizer.step()

        ## Generator update step
        gen_optimizer.zero_grad()
        
        # Forward pass 'BATCH_SIZE' number of noise vectors through Generator, and the outputs through Discriminator		
        noise_outputs = gen1.forward(torch.randn(BATCH_SIZE,NOISE_DIM))

        # Calculate generator loss and backprop on generator params
        gen_loss = criterion_gen(dis1.forward(noise_outputs),torch.zeros([BATCH_SIZE,1],dtype =torch.float32))
        gen_loss.backward()
        gen_optimizer.step()


        if i % 100 == 0:
            print('iter: %3d dis_loss: %.3f gen_loss: %.3f ' % (i, dis_loss.item(), gen_loss.item()) )
    print('One Epoch completed, saving current model')
    # Should save the model at this checkpoint
    LEARN_RATE = LEARN_RATE/10
    gen_optimizer = optim.SGD(gen1.parameters(), lr = LEARN_RATE, momentum = 0.9)
    dis_optimizer = optim.SGD(dis1.parameters(), lr = LEARN_RATE, momentum = 0.9)


# Show images generated by Generator after training

gen_images = gen1.forward(torch.randn(BATCH_SIZE,NOISE_DIM))
im = gen_images.data
img = im.view([-1,MNIST_H,MNIST_W])
print(img.size())
img = torchvision.utils.make_grid(img,nrow = 5)
print(img.size())
npimg = img.numpy()
print(np.shape(npimg))
plt.imshow(np.transpose(npimg,(1,2,0)))
plt.show()



